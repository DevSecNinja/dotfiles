#!/bin/bash
# Set default shell to fish (preferred) or zsh (fallback)
# This approach uses exec to replace the current shell process,
# which doesn't require password or chsh permissions.
# Source: https://unix.stackexchange.com/a/136424

# Only run interactively
case $- in
    *i*) ;;
      *) return 0;;
esac

# Helper function to check if parent process is fish
_parent_is_fish() {
    # Check parent process name on Linux
    if [ -f "/proc/$PPID/comm" ]; then
        [ "$(cat "/proc/$PPID/comm" 2>/dev/null)" = "fish" ] && return 0
    fi

    # Check parent process name on macOS/BSD
    if command -v ps >/dev/null 2>&1; then
        local parent_cmd
        parent_cmd=$(ps -p "$PPID" -o comm= 2>/dev/null | tr -d ' ')
        [[ "$parent_cmd" == *"fish"* ]] && return 0
    fi

    return 1
}

# Try fish first (preferred shell)
if command -v fish >/dev/null 2>&1; then
    export SHELL=$(command -v fish)
    # Only exec if:
    # - Not already in fish (FISH_VERSION not set)
    # - Not started from fish (IN_FISH_SHELL not set AND parent is not fish)
    # - And not in a nested shell (SHLVL = 1, meaning this is the initial login shell)
    # This allows users to explicitly run 'bash' from fish without being kicked back to fish
    if [ -z "$FISH_VERSION" ] && [ -z "$IN_FISH_SHELL" ] && [ "$SHLVL" -eq 1 ] && ! _parent_is_fish; then
        exec "$SHELL" -l
    fi
fi

# Fall back to zsh if fish not available
if command -v zsh >/dev/null 2>&1; then
    export SHELL=$(command -v zsh)
    # Only exec if:
    # - Not already in zsh (ZSH_VERSION not set)
    # - Not started from fish (IN_FISH_SHELL not set AND parent is not fish)
    # - And not in a nested shell (SHLVL = 1)
    if [ -z "$ZSH_VERSION" ] && [ -z "$IN_FISH_SHELL" ] && [ "$SHLVL" -eq 1 ] && ! _parent_is_fish; then
        exec "$SHELL" -l
    fi
fi

# If we get here, neither fish nor zsh are available, continue with bash
# Source bashrc for bash configuration
if [ -f "$HOME/.bashrc" ]; then
    source "$HOME/.bashrc"
fi
